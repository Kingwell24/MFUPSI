# 协议性能测试优化修改总结

## 修改时间
2026年2月9日

## 修改概述
根据性能测试实验指导文档的要求，对MUPSI协议的性能测试代码进行了两个关键阶段的修复。

---

## 问题1：Setup阶段的计时问题

### 原问题
- 掩码的生成被计入了协议的计算时间开销
- 计算通信开销的时间也被计入了协议的计算时间
- 这导致了计算时间开销被高估

### 解决方案

#### 修改1：创建全局掩码生成函数
- **文件**: `src/protocol.h` 和 `src/protocol.cpp`
- **内容**:
  - 在protocol.h中添加：
    - `void generate_global_masks();` 函数声明
    - `std::vector<MatrixType> global_masks_;` 存储全局掩码
  - 在protocol.cpp中添加generate_global_masks()的实现，在setup阶段之前生成所有客户端的掩码

#### 修改2：重新设计setup_phase()计时逻辑
- **文件**: `src/protocol.cpp`
- **关键改进**:
  1. 掩码生成在主计时开始前完成（不计入协议计算时间）
  2. 每个客户端的编码过程各自计时（使用临时Timer对象）
  3. 所有客户端的时间累加到total_client_time
  4. 计时停止后，再计算通信开销
  5. 每个客户端使用全局预生成的掩码，而不是在编码时生成

```cpp
// 原流程（错误）：
timer.start();  // 包括掩码生成和通信计算
for (each client) {
    encoding = client_encode();
    mask = generate_mask_matrix();  // 不应该计时
    masked = encoding + mask;
    // 计算通信开销  // 不应该计时
}
timer.stop();

// 新流程（正确）：
generate_global_masks();  // 提前生成，不计时

for (each client) {
    timer.start();  // 每个客户端各自计时
    encoding = client_encode();
    masked = encoding + global_masks_[i];
    timer.stop();
}
// 计算通信开销  // 在停止计时后
```

### 结果验证
从第二组测试数据：
- Setup客户端编码耗时: 3512.0000 ms（更加准确的计时）
- 通信数据正确计算: 60.0000 MB

---

## 问题2：Update阶段的客户端计时问题

### 原问题
- 随机选择要更新的客户端，生成增删元素等流程被计入了协议时间
- 掩码生成未被计时控制
- 对于不需要更新的客户端，没有计算编码+掩码的时间
- Update阶段的通信开销未被打印

### 解决方案

#### 修改：重新设计update_phase()计时逻辑
- **文件**: `src/protocol.cpp`
- **关键改进**:

1. **简化客户端选择**
   - 从随机选择改为顺序选择前N个客户端
   - 移除了无关的随机 shuffle 操作

2. **简化更新元素处理**
   - 所有更新元素均处理为一半新增、一半删除
   - 生成逻辑更加规范化

3. **独立计时每个客户端**
   ```cpp
   // 需要更新的客户端
   for (size_t i = 0; i < num_clients_to_update; i++) {
       Utils::Timer timer;
       timer.start();
       // 增量编码和掩码添加
       timer.stop();
       total_client_time += timer.elapsed_ms();
   }
   
   // 不需要更新的客户端
   for (size_t i = num_clients_to_update; i < clients_.size(); i++) {
       Utils::Timer timer;
       timer.start();
       // 只计算编码+掩码，不需要增量编码
       timer.stop();
       total_client_time += timer.elapsed_ms();
   }
   ```

4. **正确分离计时和通信计算**
   - 计时在客户端计算循环中进行
   - 计时停止后，计算通信开销
   - 打印Update阶段的通信开销

### 结果验证
从第二组测试数据：
- Update客户端耗时: 2275.0000 ms（只包括需要更新的3个客户端的增量编码 + 所有客户端的掩码添加）
- Update服务器时间: 50.0000 ms
- 更新通信: 60.0000 MB（已正确打印）

---

## 修改文件列表

1. **src/protocol.h**
   - 添加了generate_global_masks()函数声明
   - 添加了global_masks_存储向量

2. **src/protocol.cpp**
   - 添加了generate_global_masks()函数实现
   - 修改了setup_phase()函数的计时逻辑
   - 修改了update_phase()函数的计时逻辑

3. **src/main.cpp**
   - 无修改（已经包含update通信的打印）

---

## 测试结果

### 小规模测试（配置1）
- 客户端数: 3
- 数据集大小: 1024
- Setup耗时: 3.0000 ms
- Update耗时: 0.0000 ms
- 通信开销正确计算

### 中等规模测试（配置2）
- 客户端数: 10
- 数据集大小: 65536
- Setup耗时: 3512.0000 ms（精确的编码时间）
- Update耗时: 2275.0000 ms（增量编码 + 掩码时间）
- 通信开销正确计算

---

## 确认清单

### Setup阶段修复
✓ 掩码生成不计入计时
✓ 每个客户端编码各自计时
✓ 通信开销在停止计时后计算
✓ Update阶段复用全局掩码，不重新生成

### Update阶段修复
✓ 客户端选择按顺序，不用随机
✓ 更新元素处理为一半新增一半删除
✓ 需要更新客户端的增量编码计时
✓ 不需要更新客户端的编码+掩码也计时
✓ 计时区域和通信计算区域分离
✓ 打印Update阶段的通信开销

---

## 代码质量
- ✓ 编译成功通过 (Release配置, -O3优化)
- ✓ 运行成功完成两组实验
- ✓ 数据正确导出到CSV文件
- ✓ 所有性能指标正确计算和打印
