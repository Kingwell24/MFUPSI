# 多方可更新隐私集合求交协议 (Multi-party Forward-private Updatable PSI, MFUPSI)技术文档

## 3. 详细技术方案

### 3.1 Setup阶段详细技术描述

#### 3.1.1-a 全局密钥生成

**输入**: 安全参数 λ, 预期数据集大小上界 N

**输出**: 全局密钥三元组 (K₁, K₂, Kᵣ)

**密钥生成算法**:

```
Algorithm 1-a: GlobalKeyGen(λ, N)
输入: 安全参数 λ, 数据集大小上界 N
输出: 全局密钥 (K₁, K₂, Kᵣ)

1: K₁ ← {0,1}^λ  // 分区哈希密钥
2: K₂ ← {0,1}^λ  // 随机向量生成密钥
3: Kᵣ ← {0,1}^λ  // 元素表示密钥
4: return (K₁, K₂, Kᵣ)
```

**密钥分发机制**（对协议性能本身不重要）:

- **方式1(可信第三方)**: 由可信初始化方生成并安全分发给所有客户端
- **方式2(MPC)**: n个客户端通过安全多方计算协议共同生成密钥,确保无单点信任

**密钥用途**:

- K₁: 用于伪随机函数F₁,将元素映射到分区索引
  - F₁: {0,1}^λ × {0,1}* → [0, b-1]
  - 确保相同元素在所有客户端映射到相同分区
- K₂: 用于生成随机带状矩阵的行向量
  - 包含两个子函数: F₂(位置选择), F₃(值生成)
  - 确保相同元素生成相同的稀疏随机向量
- Kᵣ: 用于生成元素的加密表示
  - F: {0,1}^λ × {0,1}* → {0,1}^κ
  - 用于验证查询结果的正确性

#### 3.1.1-b 随机掩码协调生成

**目标**: 生成满足零和约束的随机掩码,用于隐藏各客户端的编码（对协议性能本身不重要）

**输入**:

- 客户端数量 n
- 编码矩阵维度 (d₁, b)
- 有限域大小 q

**输出**: 每个客户端获得掩码矩阵 $sᵢ ∈ ℤ_q^{(d₁ × b)}$, 满足 Σᵢ sᵢ = 0

```
Algorithm 1-b: CoordinateRandomMask(n, d₁, b, q)
输入: 客户端数量n, 矩阵维度(d₁, b), 有限域大小q
输出: 每个客户端的掩码 s₁, s₂, ..., sₙ

// 方案1: 基于秘密分享的掩码生成
1: Clientₙ 生成随机目标掩码 S_target ← 随机矩阵(d₁ × b, ℤ_q)
2: Clientₙ 初始化累积掩码 S_acc ← S_target
3: for i = 1 to n-1 do
4:    Clientᵢ 生成随机掩码 sᵢ ← 随机矩阵(d₁ × b, ℤ_q)
5:    Clientᵢ 发送 sᵢ 给 Clientₙ
6:    Clientₙ 更新 S_acc ← S_acc - sᵢ (mod q)
7: end for
8: Clientₙ 设置 sₙ ← S_acc
9: // 验证: s₁ + s₂ + ... + sₙ = S_target + (s₁+...+s_{n-1}) - (s₁+...+s_{n-1}) = S_target
10: Clientₙ 广播 S_target
11: 所有客户端调整: sᵢ ← sᵢ - S_target/n (mod q) (使得 Σᵢ sᵢ = 0)
12: return {s₁, s₂, ..., sₙ}

// 方案2: 基于Shamir秘密分享的去中心化方案
// (适用于无可信协调方的场景)
1: 所有客户端共同运行 (n,n)-threshold秘密分享协议
2: 目标秘密: 零矩阵 0^(d₁×b)
3: 每个客户端 Clientᵢ 获得份额 sᵢ
4: 保证: Σᵢ sᵢ = 0 (Shamir重构性质)
5: return {s₁, s₂, ..., sₙ}
```

**方案对比**:

| 方案            | 优势              | 劣势                | 适用场景     |
| --------------- | ----------------- | ------------------- | ------------ |
| 方案1(秘密分享) | 简单高效,通信O(n) | 需要协调方Clientₙ   | 有可信协调方 |
| 方案2(Shamir)   | 完全去中心化      | 通信O(n²), 计算较重 | 无可信方     |

**安全性保证**:

- 任意k < n个客户端合谋,无法推断剩余客户端的掩码
- 基于加法秘密分享的信息论安全性
- 即使服务器与k个客户端合谋,仍无法获取其他客户端的真实编码

**实现优化**:

1. **稀疏掩码**: 如果更新是稀疏的,可以只为受影响的列生成掩码
2. **预计算**: 可以在两次更新之间预先生成下一轮的掩码
3. **批量生成**: 一次生成多轮的掩码,减少协调开销

#### 3.1.2 客户端本地编码算法

每个客户端Clientᵢ独立执行以下编码过程:

**输入**:

- 本地数据集 Xᵢ = {x₁, x₂, ..., x_{nᵢ}}
- 全局密钥 (K₁, K₂, Kᵣ)
- 系统参数: d₁(分区容量), w(带宽), ε(超额因子), b(分区数量)

**输出**: 编码矩阵 Eᵢ ∈ ℝ^(d₁ × b)

```
Algorithm 2: ClientEncode(Xᵢ, K₁, K₂, Kᵣ, d₁, w, ε)
// 所有线性代数运算在有限域ℤ_q上进行
// q为素数，满足q > n·2^(κ+1)，其中κ为F(Kᵣ,·)输出长度
输入: 数据集Xᵢ, 密钥(K₁, K₂, Kᵣ), 参数(d₁, w, ε)
输出: 编码矩阵 Eᵢ

// 步骤1: 计算分区数量
1: b ← ⌈(1+ε)|Xᵢ|/d₁⌉
2: m ← (1+ε)|Xᵢ|  // 总容量

// 步骤2: 数据集分区
3: 初始化 b 个空分区: P₁, P₂, ..., P_b ← ∅
4: for each x ∈ Xᵢ do
5:    j ← F₁(K₁, x) mod b  // 确定分区索引
6:    P_{j+1} ← P_{j+1} ∪ {(x, flag=1)}  // flag为y最后一位，元素存在则设置为1
7: end for

// 步骤3: 对每个分区进行编码
8: 初始化编码矩阵 Eᵢ ← []
9: for j = 1 to b do
10:   e_j ← EncodePartition(P_j, K₂, Kᵣ, d₁, w)
11:   将 e_j 作为列添加到 Eᵢ
12: end for

13: return Eᵢ
```

**分区编码子算法**:

```
Algorithm 3: EncodePartition(P_j, K₂, Kᵣ, d₁, w)
// 所有线性代数运算在有限域ℤ_q上进行
// q为素数，满足q > n·2^(κ+1)，其中κ为F(Kᵣ,·)输出长度
输入: 分区P_j, 密钥(K₂, Kᵣ), 参数(d₁, w)
输出: 编码向量 e_j ∈ ℝ^d₁

// 步骤1: 构建随机带状矩阵M和目标向量y
1: M ← []  // m_j × d₁ 矩阵,其中m_j = |P_j|
2: y ← []  // m_j 维向量
3: for each (x, flag) ∈ P_j do
4:    // 生成稀疏随机行向量
5:    v_x ← RandVector(K₂, x, d₁, w)  // Algorithm 4
6:    将 v_x 作为行添加到 M
7:    
8:    // 生成目标值
9:    y_x ← F(Kᵣ, x) || flag  // κ+1 位
10:   将 y_x 添加到 y
11: end for

// 步骤2: 求解线性系统 M·e_j = y
12: 对M的行按首个非零元素位置排序
13: e_j ← GaussianElimination(M, y)  // 高斯消元法（在有限域ℤ_q上进行）

14: return e_j
```

**随机向量生成算法** (继承自FUPSI):

```
Algorithm 4: RandVector(K₂, x, d₁, w)
输入: 密钥K₂, 元素x, 维度d₁, 带宽w
输出: 稀疏随机向量 v ∈ {0,1}^d₁

1: p ← F₃(K₂, x || "position") mod (d₁ - w + 1)  // 起始位置
2: 初始化 v ← [0, 0, ..., 0]  // d₁维零向量
3: for i = 1 to w do
4:    v[p + i] ← F₂(K₂, x || i) mod 2  // 填充w个连续位置
5: end for
6: return v
```

**数学原理解释**:

1. **分区的一致性**:
   - 所有客户端使用相同的K₁和F₁函数
   - 因此相同元素x在所有客户端映射到相同分区索引j
   - 即: F₁(K₁, x) mod b 对所有客户端产生相同结果
2. **随机向量的一致性**:
   - 对于相同元素x,所有客户端生成相同的随机向量v_x
   - 即: RandVector(K₂, x, d₁, w) 在所有客户端产生相同输出
   - 这是因为F₂和F₃是确定性伪随机函数
3. **目标值的一致性**:
   - 对于相同元素x,所有客户端生成相同的y_x
   - 即: F(Kᵣ, x) || flag 中的F(Kᵣ, x)部分相同
   - flag部分在编码时都设为1(表示存在)
4. **线性系统的可解性**:
   - 随机带状矩阵M以高概率具有满行秩
   - 因此线性系统 M·e_j = y 有唯一解
   - 高斯消元法可高效求解(复杂度O(w·d₁²))

#### 3.1.3 编码上传与全局聚合

**客户端上传**:

```
Algorithm 5: ClientUpload(Eᵢ)
输入: 客户端i的编码矩阵 Eᵢ
输出: 无(数据上传至服务器)

1: 计算掩码后的编码 Ẽᵢ ← Eᵢ + sᵢ (mod q)  // 逐元素相加
2: 建立与云服务器的安全通道
3: 发送 (ClientID=i, MaskedEncoding=Ẽᵢ) 到服务器
4: 等待服务器确认接收
```

**服务器端全局聚合**:

```
Algorithm 6: ServerAggregate(Ẽ₁, Ẽ₂, ..., Ẽₙ)
输入: n个客户端的掩码编码矩阵 Ẽ₁, Ẽ₂, ..., Ẽₙ
输出: 全局聚合编码 E_total ∈ ℤ_q^(d₁ × b)

1: 初始化 E_total ← 零矩阵(d₁ × b)
2: for i = 1 to n do
3:    E_total ← E_total + Ẽᵢ (mod q)  // 矩阵逐元素相加
4: end for
5: // 此时 E_total = Σᵢ(Eᵢ + sᵢ) = Σᵢ Eᵢ + Σᵢ sᵢ = Σᵢ Eᵢ + 0 = Σᵢ Eᵢ
6: 存储 E_total 以供后续查询使用
7: return E_total
```

**掩码消除的数学原理**:

设各客户端的真实编码为 E₁, E₂, ..., Eₙ, 掩码为 s₁, s₂, ..., sₙ

服务器计算:

```
E_total = Ẽ₁ + Ẽ₂ + ... + Ẽₙ (mod q)
        = (E₁ + s₁) + (E₂ + s₂) + ... + (Eₙ + sₙ) (mod q)
        = (E₁ + E₂ + ... + Eₙ) + (s₁ + s₂ + ... + sₙ) (mod q)
        = (E₁ + E₂ + ... + Eₙ) + 0 (mod q)        (零和约束)
        = E₁ + E₂ + ... + Eₙ (mod q)               (正确的全局编码)
```

**隐私保护机制**:

1. 单个编码不可解释:
   - 服务器看到的 Ẽᵢ = Eᵢ + sᵢ 在计算上不可区分于随机矩阵
   - 由于sᵢ是均匀随机的,Ẽᵢ继承了这种随机性
   - 即使服务器知道编码算法,也无法从Ẽᵢ恢复Eᵢ
2. 历史编码不可关联:
   - 假设在轮次t服务器观察到 $Ẽᵢ^{(t)} = Eᵢ^{(t)} + sᵢ^{(t)}$
   - 在轮次t+1观察到 $Ẽᵢ^{(t+1)} = Eᵢ^{(t+1)} + sᵢ^{(t+1)}$
   - 由于$sᵢ^{(t)}$ 和$sᵢ^{(t+1)}$独立随机,服务器无法关联这两个编码
   - 即使$Eᵢ^{(t)}$ = $Eᵢ^{(t+1)}$(客户端无更新), $Ẽᵢ^{(t)} ≠ Ẽᵢ^{(t+1)}$
3. 合谋抵抗性:
   - 假设服务器与k < n个客户端合谋
   - 已知: Ẽ₁, ..., Ẽₖ, s₁, ..., sₖ (合谋客户端的掩码)
   - 可计算: E₁, ..., Eₖ (去除掩码)
   - 目标: 推断 E_{k+1}, ..., Eₙ
   - **不可行**: 从 $E_{total} = Σᵢ Eᵢ$ 和 E₁, ..., Eₖ 可得$ Σ_{i>k} Eᵢ = E_{total} - Σ_{i<=k} Eᵢ$
   - 但这仍是n-k个编码的和,无法进一步分解(除非n-k=1)

**定理 (掩码后的编码不可区分性)**: 在随机预言机模型下,服务器的视图 {Ẽ₁, ..., Ẽₙ} 与 {R₁, ..., Rₙ} 在计算上不可区分,其中Rᵢ是均匀随机矩阵。

**证明草图**:

1. 由于 sᵢ ← Uniform(ℤ_q^(d₁×b)),sᵢ是均匀随机的
2. 对于任意Eᵢ, Ẽᵢ = Eᵢ + sᵢ 的分布与 sᵢ 相同(one-time pad性质)
3. 因此 Ẽᵢ ≈ Uniform(ℤ_q^(d₁×b)) ≈ Rᵢ
4. 由于各Ẽᵢ独立(各sᵢ独立), {Ẽ₁, ..., Ẽₙ} ≈ {R₁, ..., Rₙ}

**核心数学创新: 编码可加性**

这是本方案最关键的创新点。考虑全局交集元素x ∈ X₁ ∩ X₂ ∩ ... ∩ Xₙ:

设x被映射到分区j,即 j = F₁(K₁, x) mod b

在每个客户端的编码中:

- Client₁: 有方程 v_x · e₁_j = y_x (其中y_x = F(Kᵣ, x) || 1)
- Client₂: 有方程 v_x · e₂_j = y_x (相同的v_x和y_x!)
- ...
- Clientₙ: 有方程 v_x · e_ₙ_j = y_x

**关键观察**: 由于密钥全局一致,v_x和y_x对所有客户端都相同!

当查询元素x时:

```
v_x · E_total_j = v_x · (e₁_j + e₂_j + ... + e_ₙ_j) (mod q)
                = v_x · e₁_j + v_x · e₂_j + ... + v_x · e_ₙ_j (mod q)
                = y_x + y_x + ... + y_x  (n次) (mod q)
                = n · y_x (mod q)
                = n · (F(Kᵣ, x) || 1) (mod q)
```

**交集判断准则**:

- 如果查询结果 = flag_sum · y_x,说明x在所有客户端中都存在 → x ∈ 全局交集
- 如果查询结果 ≠ flag_sum · y_x,说明x不是全局交集元素

**数学正确性证明**:

**引理**: 如果元素x不在所有客户端中存在,则:

```
v_x · E_total_j = 随机值 (与y_x无关)
```

**定理**: MFUPSI的全局交集判断是完备且正确的:

- **完备性**: 如果x ∈ ∩ᵢXᵢ,则必有 v_x · E_total_j = flag_sum · y_x
- **正确性**: 如果 v_x · E_total_j = flag_sum · y_x,则必有 x ∈ ∩ᵢXᵢ

**证明**:

1. 完备性由线性方程的可加性直接得出
2. 正确性由以下事实保证:
   - F(Kᵣ, ·)是伪随机函数,碰撞概率可忽略
   - 随机带状矩阵确保不同元素产生独立的方程
   - 因此不会出现误判

### 3.2 Update阶段详细技术描述

#### 3.2.1 客户端增量编码算法

当客户端Clientᵢ的数据集发生变化时:

**输入**:

- 新增元素集合 X_add ⊆ Xᵢ_new
- 删除元素集合 X_del ⊆ Xᵢ_old
- 旧编码矩阵 Eᵢ_old
- 全局密钥 (K₁, K₂, Kᵣ)

**输出**:

- 增量编码 δEᵢ

```
Algorithm 7: ClientIncrementalUpdate(X_add, X_del, Eᵢ_old, K₁, K₂, Kᵣ)
输入: 更新集合(X_add, X_del), 旧编码Eᵢ_old, 密钥(K₁, K₂, Kᵣ)
输出: 增量编码 δEᵢ

// 步骤1: 识别受影响的分区
1: affected_partitions ← ∅
2: for each x ∈ (X_add ∪ X_del) do
3:    j ← F₁(K₁, x) mod b
4:    affected_partitions ← affected_partitions ∪ {j}
5: end for

// 步骤2: 初始化增量编码矩阵
6: δEᵢ ← 零矩阵(d₁ × b)

// 步骤3: 对每个受影响的分区重新编码
7: for each j ∈ affected_partitions do
8:    // 重建该分区的元素集合
9:    P_j_new ← ∅
10:   for each x ∈ Xᵢ_new do
11:      if F₁(K₁, x) mod b = j then
12:         flag ← 1  // 存在元素
13:         if x ∈ X_del then
14:            erase x from P_j
15:         end if
16:         P_j_new ← P_j_new ∪ {(x, flag)}
17:      end if
18:   end for
19:   
20:   // 重新编码该分区
21:   e_j_new ← EncodePartition(P_j_new, K₂, Kᵣ, d₁, w)
22:   
23:   // 计算增量
24:   δe_j ← e_j_new - Eᵢ_old[:, j]  // 列向量相减
25:   δEᵢ[:, j] ← δe_j
26: end for

27: return δEᵢ
```

**关键技术细节**:

1. **部分重新编码策略**:

   - 只需重新编码包含变化元素的分区
   - 其他分区的编码保持不变(对应δEᵢ中的零列)
   - 大幅减少计算开销

2. **删除操作的处理**:

   - 删除元素x时,将其从分区中移除即可
   - 重新编码该分区时,x对应的方程变为: v_x · e_j = 随机值
   - 这导致 v_x · e_j_new ≠ y_x,从而在查询时被识别为"已删除"

3. **增量计算的数学原理**:

   ```
   E_total_new = (E₁_old + δE₁) + (E₂_old + δE₂) + ... + (Eₙ_old + δEₙ)
               = (E₁_old + E₂_old + ... + Eₙ_old) + (δE₁ + δE₂ + ... + δEₙ)
               = E_total_old + Σᵢ δEᵢ
   ```

   因此服务器只需执行向量加法即可完成全局更新

#### 3.2.2 服务器端增量更新算法

**关键要求**: 所有n个客户端都必须在每轮更新中提交,即使某些客户端无数据变化

```
Algorithm 8: ServerIncrementalUpdate(δẼ₁, δẼ₂, ..., δẼₙ)
输入: 所有n个客户端的掩码增量编码 δẼ₁, δẼ₂, ..., δẼₙ
输出: 更新后的全局编码 E_total_new

1: 从存储中加载当前全局编码 E_total_old
2: 初始化 E_total_new ← E_total_old
3: for i = 1 to n do
4:    E_total_new ← E_total_new + δẼᵢ (mod q)  // 矩阵逐元素相加
5: end for
6: // 此时 E_total_new = E_total_old + Σᵢ(δEᵢ + s'ᵢ) 
7: //                  = E_total_old + Σᵢ δEᵢ + Σᵢ s'ᵢ
8: //                  = E_total_old + Σᵢ δEᵢ + 0
9: //                  = E_total_old + Σᵢ δEᵢ  (正确的更新)
10: 存储更新后的编码 E_total_new
11: return E_total_new
```

**强制全员参与机制**:

为确保掩码消除,必须强制所有客户端在每轮更新中都提交:

```
Algorithm 8-b: EnforceFullParticipation()
输入: 无
输出: 确保所有客户端提交

1: 服务器设置更新轮次deadline
2: 服务器维护提交客户端列表 submitted_clients ← ∅
3: while 当前时间 < deadline do
4:    接收客户端提交 (ClientID=i, δẼᵢ)
5:    submitted_clients ← submitted_clients ∪ {i}
6: end while
7: if |submitted_clients| < n then
8:    // 未全员提交,拒绝此轮更新
9:    向所有已提交客户端返回错误
10:   回滚到 E_total_old
11: else
12:   // 全员提交,执行更新
13:   执行 ServerIncrementalUpdate(δẼ₁, ..., δẼₙ)
14: end if
```

**客户端无更新时的处理**:

即使客户端本轮无数据更新,也必须提交掩码后的零增量:

```
Algorithm 7-b: ClientNoUpdateSubmission(s'ᵢ)
输入: 客户端i的掩码分片 s'ᵢ
输出: 无(提交给服务器)

1: δEᵢ ← 零矩阵(d₁ × b)  // 无数据更新
2: δẼᵢ ← δEᵢ + s'ᵢ = s'ᵢ   // 仅包含掩码
3: 发送 (ClientID=i, δẼᵢ) 到服务器
```

**掩码更新的数学原理**:

在更新轮t,设:

- 客户端i的真实增量: δEᵢ (可能为0)
- 客户端i的新掩码: s'ᵢ
- 约束: Σᵢ s'ᵢ = 0

服务器计算:

```
E_total^(t+1) = E_total^(t) + Σᵢ δẼᵢ
              = E_total^(t) + Σᵢ (δEᵢ + s'ᵢ)
              = E_total^(t) + Σᵢ δEᵢ + Σᵢ s'ᵢ
              = E_total^(t) + Σᵢ δEᵢ + 0
              = E_total^(t) + Σᵢ δEᵢ
```

**隐私保护增强**:

1. 更新模式隐藏:
   - 服务器无法区分哪些客户端有真实更新,哪些只是提交掩码
   - 所有δẼᵢ在服务器视角下都是随机矩阵
2. 更新幅度隐藏:
   - 即使客户端有大量更新,掩码也会隐藏增量的真实大小
   - 服务器无法通过||δẼᵢ||推断更新数据量
3. 时序去关联:
   - 每轮使用新的独立掩码s'ᵢ
   - 即使客户端连续多轮无更新(δEᵢ^(t) = δEᵢ^(t+1) = 0)
   - 服务器看到的 δẼᵢ^(t) ≠ δẼᵢ^(t+1) (掩码不同)

**通信开销分析**:

- 无掩码版本: 只有k个有更新的客户端提交,通信量O(k·Δ)
- **有掩码版本**: 所有n个客户端都提交,通信量O(n·d₁·b)
- **权衡**: 牺牲一定通信效率换取更强的隐私保护
- **优化**: 可使用稀疏编码格式,只传输非零元素

**通信开销分析**:

- 客户端只需发送增量编码δEᵢ,而非完整编码Eᵢ
- δEᵢ中只有受影响分区的列非零
- 如果更新数据量为Δ,受影响分区数约为 Δ/d₁
- 通信量: O(d₁ · Δ/d₁) = O(Δ)

**计算开销分析**:

- 客户端: 只需重新编码受影响分区,复杂度O(Δ)
- 服务器: 简单的矩阵加法,复杂度O(d₁ · b)

### 3.3 Query阶段详细技术描述

#### 3.3.1 查询向量生成算法

查询客户端(如Client₁)需要为每个查询元素x生成查询向量:

```
Algorithm 9: GenerateQueryVector(x, K₁, K₂, d₁, w, b, z)
输入: 查询元素x, 密钥(K₁, K₂), 参数(d₁, w, b, z)
输出: 查询向量组 (v₁, v₂, ..., v_z)

// 步骤1: 确定元素所在分区
1: j ← F₁(K₁, x) mod b

// 步骤2: 生成第一维查询向量(核心查询向量)
2: v₁ ← RandVector(K₂, x, d₁, w)  // 与编码时完全相同!

// 步骤3: 生成多维PIR索引向量
3: for dim = 2 to z do
4:    j_dim ← ⌊j / ⌈b/d_dim⌉⌋  // 计算该维度的索引
5:    v_dim ← 零向量(d_dim)
6:    v_dim[j_dim] ← 1  // 标准基向量
7: end for

8: return (v₁, v₂, ..., v_z)
```

**关键技术点**:

1. **查询向量的一致性**:
   - v₁ = RandVector(K₂, x, d₁, w) 与编码时使用的向量完全相同
   - 这确保了 v₁ · e_j 能正确提取出 y_x
2. **多维PIR技术**:
   - 为了减少PIR开销,将b个分区组织成z维超立方体
   - 例如: b=64时,可用z=2,d₂=8的2D布局(64 = 8×8)
   - 查询变成多维坐标查询,通信开销从O(b)降至O(z·∜b)

#### 3.3.2 PIR查询与响应协议

本协议使用标准的关键字PIR(Keyword PIR)技术,具体可采用:

- Lattice-based PIR (如OnionPIR)
- 或其他高效PIR方案

**客户端PIR请求生成**:

```
Algorithm 10: ClientGeneratePIRRequest(x, K₁, K₂, Kᵣ, PIR_params)
输入: 查询元素x, 密钥, PIR参数
输出: PIR请求 req, 客户端状态 st

1: (v₁, v₂, ..., v_z) ← GenerateQueryVector(x, K₁, K₂, ...)
2: (req, st_PIR) ← Π_PIR.Query(client_key, v₁, v₂, ..., v_z)
3: st ← (st_PIR, x)  // 保存状态以供后续解密
4: return (req, st)
```

**服务器PIR响应计算**:

```
Algorithm 11: ServerAnswerPIRRequest(req, E_total, PIR_params)
输入: PIR请求req, 全局编码E_total, PIR参数
输出: PIR响应 resp

1: resp ← Π_PIR.Answer(server_key, E_total, req)
2: return resp
```

**PIR协议的数学原理** (以OnionPIR为例):

设E_total是d₁×b的矩阵,查询向量为(v₁, v₂)

1. **客户端加密查询**:
   - 使用LWE加密v₁为密文c₁
   - 使用LWE加密v₂为密文c₂
2. **服务器同态计算**:
   - 计算 c₁ · E_total (在密文域)
   - 得到中间结果 enc(v₁ · E_total)
   - 进一步应用v₂提取目标列
3. **客户端解密**:
   - 使用LWE解密得到 v₁ · E_total_j

**关键性质**:

- 服务器不知道v₁和v₂的值,因此不知道查询的是哪个元素
- 访问模式(access pattern)被PIR完全隐藏
- 搜索模式(search pattern)也被隐藏(每次查询使用新鲜的随机性)

#### 3.3.3 查询结果解密与交集判断

```
Algorithm 12: ClientDecryptAndJudge(resp, st, x, Kᵣ, n, I_old)
输入: PIR响应resp, 状态st, 查询元素x, 密钥Kᵣ, 客户端数量n, 旧交集I_old
输出: 更新后的交集信息 (I_new, I_old_updated)

// 步骤1: 解密PIR响应
1: 解析 st 为 (st_PIR, x)
2: u ← Π_PIR.Decrypt(client_key, st_PIR, resp)
3: 解析 u 为 (received_key, received_count)

// 步骤2: 计算预期值
4: x_key ← F(Kᵣ, x)  // x的预期key
5: expected_flag_sum ← n · 1 = n    // 全局交集时的预期flag_sum为总客户端数
6: expected_key ←x_key · expected_flag_sum // 全局交集时的预期key

// 步骤3: 执行判断逻辑
7: I_new ← ∅
8: I_old_updated ← I_old

9: if received_key = expected_key then
10:    // 说明x在所有客户端中都存在
      if x not ∈ I_old then
11:         I_new ← I_new ∪ {x}
12: else
13:   // 说明x不在全局交集中
14:   if x ∈ I_old then
15:         I_old_updated ← I_old_updated \ {x}
16: end if

17: return (I_new, I_old_updated)
```

**判断逻辑的详细解释**:

**情况1: received_key = flag_sum·F(Kᵣ, x) **

- **数学含义**: v_x · E_total_j = n · (F(Kᵣ, x) || 1)
- **实际含义**: x在所有n个客户端中都存在且flag=1
- **结论**: x ∈ 全局交集
- **操作**: 将x添加到新交集I_new

**情况2: received_key ≠ n·F(Kᵣ, x) **

- **数学含义**: 存在客户端的对应解密值为随机值
- **实际含义**: x不是全局交集元素
- **结论**: x ∉ 全局交集
- **操作**: 如果x在I_old中,则从I_old中移除

**计数机制的实现细节**:

为了在编码中嵌入计数信息,我们扩展表示向量的结构:

```
rep(Kᵣ, x, flag) = F(Kᵣ, x) || flag
                    ^^^^^^^   ^^^^   
                    κ位       1位1    
```

当n个客户端的交集元素编码相加时:

```
Σᵢ rep(Kᵣ, x, flagᵢ) = Σᵢ flagᵢ·F(Kᵣ, x) || (Σᵢ flagᵢ) 
```

- Σᵢ flagᵢ·F(Kᵣ, x): 用于身份验证
- Σᵢ flagᵢ = n: 总客户端数量

**健壮性考虑**:

1. **噪声处理**:
   - PIR解密可能产生小噪声
   - 需要设置容错阈值ε,使得 |received_count - n| < ε 时仍判定为全局交集
2. **溢出处理**:
   - 确保有限域足够大,避免 n·F(Kᵣ, x) 溢出
   - 选择域大小 ≥ n·2^κ

### 3.4 完整协议执行流程

下面展示一个完整的多轮执行示例:

**初始状态(轮次0)**:

```
Client₁: X₁ = {1, 2, 3}
Client₂: X₂ = {2, 3, 4}
Client₃: X₃ = {3, 4, 5}
```

**Setup阶段**:

1. 生成全局密钥(K₁, K₂, Kᵣ)
2. 各客户端编码:
   - E₁ = Encode(X₁, keys)
   - E₂ = Encode(X₂, keys)
   - E₃ = Encode(X₃, keys)
3. 服务器聚合: E_total = E₁ + E₂ + E₃

**Query阶段(轮次0)**: Client₁查询元素{1,2,3}:

- 查询1: v₁ · E_total → 1·y₁ (只有Client₁有) → 1 ∉ 交集
- 查询2: v₂ · E_total → 2·y₂ (Client₁,Client₂有) → 2 ∉ 交集
- 查询3: v₃ · E_total → 3·y₃ (所有客户端都有) → **3 ∈ 交集**

结果: I₀ = {3}

**Update阶段(轮次1)**:

```
Client₁: 添加元素{4}, 删除元素{1}
Client₂: 添加元素{5}
Client₃: 无更新
```

各客户端计算增量:

- δE₁: 包含元素4和1变化的分区
- δE₂: 包含元素5变化的分区
- δE₃: 零矩阵(无变化)

服务器更新:

```
E_total_new = E_total_old + δE₁ + δE₂ + δE₃
```

**Query阶段(轮次1)**: Client₁查询元素{2,3,4,5}:

- 查询2: 结果仍为随机值  ∉ 交集
- 查询3: 结果为3·y₃ → **3 ∈ 交集**(保持)
- 查询4: 结果为随机值  ∉ 交集
- 查询5: 结果为随机值  ∉ 交集

结果: I₁ = {3}

------

## 5. 性能分析与优化

### 5.1 计算复杂度分析

**Setup阶段**:

| 操作         | 复杂度         | 说明                 |
| ------------ | -------------- | -------------------- |
| 密钥生成     | O(λ)           | 一次性操作           |
| 客户端分区   | O(nᵢ)          | 每个客户端对其数据集 |
| 随机矩阵构建 | O(nᵢ · w)      | w是带宽参数          |
| 高斯消元     | O(nᵢ · w · d₁) | 主导开销             |
| 服务器聚合   | O(d₁ · b)      | 矩阵加法             |

**单客户端总复杂度**: O(nᵢ · w · d₁)

**Update阶段**:

| 操作               | 复杂度         | 说明             |
| ------------------ | -------------- | ---------------- |
| 识别受影响分区     | O(Δᵢ)          | Δᵢ是更新数据量   |
| 重新编码受影响分区 | O(Δᵢ · w · d₁) | 只编码变化的分区 |
| 增量计算           | O(Δᵢ)          | 向量减法         |
| 服务器更新         | O(d₁ · b)      | 矩阵加法         |

**单客户端总复杂度**: O(Δᵢ · w · d₁)

- 相比完全重新编码的O(nᵢ · w · d₁),节省因子为 nᵢ/Δᵢ

**Query阶段**:

| 操作          | 复杂度    | 说明     |
| ------------- | --------- | -------- |
| 查询向量生成  | O(w)      | 稀疏向量 |
| PIR请求生成   | O(z · d)  | 多维PIR  |
| 服务器PIR计算 | O(d₁ · b) | 同态点积 |
| PIR解密       | O(z · d)  | LWE解密  |
| 交集判断      | O(1)      | 常数时间 |

**单次查询总复杂度**: O(d₁ · b + z · d)

- 对于q个查询: O(q · (d₁ · b + z · d))

### 5.2 通信复杂度分析

**Setup阶段**:

| 通信               | 大小          | 说明                   |
| ------------------ | ------------- | ---------------------- |
| 密钥分发           | O(λ)          | 广播给n个客户端        |
| 掩码协调           | O(n · d₁ · b) | 生成零和掩码(方案依赖) |
| 客户端上传掩码编码 | O(d₁ · b)     | 每个客户端上传Ẽᵢ       |
| 总通信量           | O(n · d₁ · b) | 主导开销               |

**Update阶段**:

| 通信         | 大小          | 说明                     |
| ------------ | ------------- | ------------------------ |
| 掩码协调     | O(n · d₁ · b) | 每轮生成新掩码           |
| 掩码增量上传 | O(d₁ · b)     | **每个客户端**都必须上传 |
| 单轮总通信量 | O(n · d₁ · b) | 强制全员参与             |

**重要说明**:

- **无掩码版本**: 只有k个有更新的客户端提交,通信量O(k · Δ)
- **有掩码版本**: 所有n个客户端都必须提交,通信量O(n · d₁ · b)
- **通信开销增加**: 从O(k)增加到O(n),其中k是有更新的客户端数
- **权衡**: 牺牲通信效率换取显著增强的隐私保护(历史去关联)

**Query阶段**:

| 通信          | 大小                 | 说明        |
| ------------- | -------------------- | ----------- |
| PIR请求       | O(z · d · log q)     | LWE密文大小 |
| PIR响应       | O(log q)             | 单个元素    |
| 单次查询通信  | O(z · d · log q)     | 主导开销    |
| q次查询总通信 | O(q · z · d · log q) |             |

**通信优化策略**:

1. 稀疏编码表示:
   - 使用CSR/CSC格式只传输非零元素
   - 对于稀疏更新,可显著减少实际传输量
   - 即使δEᵢ = 0,也只需传输掩码s'ᵢ的非零部分
2. 压缩技术:
   - 掩码矩阵Ẽᵢ和δẼᵢ可用通用压缩算法(zlib, lz4)
   - 由于掩码是随机的,压缩效果有限,但仍可节省10-20%
3. 批量查询:
   - 将多个查询打包成单个PIR请求
   - 利用批量PIR技术减少通信轮次
4. 掩码预计算:
   - 在两次更新之间预先协调生成下k轮的掩码
   - 减少实时协调开销
   - 存储成本: 每客户端O(k · d₁ · b)

**实际通信量估算**:

假设参数: n=50, d₁=96, b=1000, q=2^64, 元素大小8字节

**Setup阶段**:

- 单客户端上传: 96 × 1000 × 8 = 768 KB
- 总上传量: 50 × 768 KB ≈ 37.5 MB
- 掩码协调(Shamir): O(n²) ≈ 100 MB (一次性)

**Update阶段(每轮)**:

- 单客户端上传: 768 KB (即使无更新)
- 总上传量: 50 × 768 KB ≈ 37.5 MB
- 掩码协调: 同上
- **与无掩码对比**: 如果只有5个客户端有更新,无掩码版本仅需3.75 MB,增加了10倍

**Query阶段(SimplePIR,单次查询)**:

- PIR请求: ≈ 100 KB
- PIR响应: ≈ 10 KB
- 1000次查询: ≈ 100 MB

**总结**: 掩码机制主要增加Update阶段的通信开销,在隐私和效率间提供可调节的权衡

### 5.3 参数选择指导

**建议参数配置表（继承于SparsePIR）：**

| **参数符号**   | **含义**                    | **推荐值 (参考 SparsePIR)**         | **说明**                                                     |
| -------------- | --------------------------- | ----------------------------------- | ------------------------------------------------------------ |
| **$N$**        | RLWE 多项式度数             | **4096 或 8192**                    | 取决于安全参数 $\lambda=128$。通常 Spiral/OnionPIR 用 4096 即可。 |
| **$d_1$**      | 分区大小 (Partition Size)   | **512 或 1024**                     | [SparsePIR] 实验显示 $d_1=512$ 是计算与通信的最佳平衡点。    |
| **$\epsilon$** | 扩展因子 (Expansion Factor) | **0.1 到 0.2**                      | 决定了编码成功率。设为 0.15 比较保险，即编码长度是原始数据的 1.15 倍。 |
| **$w$**        | 带宽 (Band Width)           | **60 到 100**                       | 决定带状矩阵的稀疏度。$w$ 越小编码越快，但求解失败率越高。[SparsePIR] 推荐 60-120。 |
| **$q$**        | 有限域模数                  | **$2^{64}$ 附近的素数**             | 为了防止 $n \cdot y$ 溢出，域必须足够大。                    |
| **$b$**        | 分区数量                    | $\lceil (1+\epsilon)n / d_1 \rceil$ | 根据总数据量 $n$ 自动计算。                                  |
