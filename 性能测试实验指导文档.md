这是一份为 MUPSI 协议性能评估量身定制的实验指导文档。

这份文档的核心原则是：**“计算规模真实，逻辑结果模拟”**。即所有消耗 CPU 时间的数学运算（如高斯消元、大整数矩阵乘法、同态加密运算）都必须基于真实的维度和算法复杂度进行执行，以获取准确的时间开销；但对于运算后的数值结果是否正确（能否解密出明文），不做要求。

------

# MUPSI 协议性能评估实验指导文档

## 1. 实验目标与总体原则

- **目标**：统计 MUPSI 协议在 Setup、Update、Query 三个阶段的 **计算时延 (Computational Latency)** 和 **通信开销 (Communication Overhead)**。
- **原则**：
  - **Setup/Update 阶段**：必须完整执行分区、构建带状矩阵、高斯消元求解、掩码加法。这是为了体现编码的真实代价。
  - **Query 阶段**：必须模拟底层 PIR (如 OnionPIR) 的 GSW 加密（查询生成）和 同态扩展与检索（服务器处理）。这是为了体现同态加密的真实代价。
  - **忽略正确性**：不验证解密结果是否匹配，不处理哈希碰撞的边缘情况，只关注程序跑完流程所需的时间和生成的数据包大小。

------

## 2. 全局参数配置 (Configuration)

在代码中定义一个 `Config` 类或字典，支持灵活修改以下参数。建议参考 FUPSI 和 SparsePIR 的推荐值 。

| **参数名**     | **符号**    | **推荐值**                                    | **说明**                    |
| -------------- | ----------- | --------------------------------------------- | --------------------------- |
| **客户端数量** | $n$         | `[2, 3, 5, 10, 50, 100]`                      | 实验变量，测试多方扩展性    |
| **数据集大小** | $N_{size}$  | `2^16` (65536) 或 `2^20`                      | 单个客户端的数据量          |
| **更新数据量** | $N_{upd}$   | `0.01 * N_size` (对16次方是1%，20次方为0.05%) | Update 阶段新增/删除的数量  |
| **查询数量**   | $N_{query}$ | `1,10,100,1000`                               | Query 阶段批量查询的数量    |
| **分区容量**   | $d_1$       | `512` 或 `1024`                               | 核心参数，影响编码和PIR效率 |
| **扩展因子**   | $\epsilon$  | `0.2`                                         | 用于计算分区总数 $b$        |
| **PIR 维度**   | $z$         | `2` 或 `3`                                    | 将线性数据库折叠的维度      |
| **LWE 维度**   | $N_{lwe}$   | `1024` 或 `2048`                              | PIR 安全参数，影响矩阵大小  |
| **模数**       | $q$         | `2^64` (uint64)                               | 运算数域                    |

**预计算参数**：

- 分区总数 $b = \lceil \frac{n \times N_{size} \times \epsilon}{d_1} \rceil$
- PIR 每一维的折叠大小 $d_{pir} = b^{1/z}$ (近似值，用于模拟计算规模)

------

## 3. 阶段一：Setup (系统初始化)

**无需计时部分**：

1. **数据生成**：为 $n$ 个客户端生成随机数据集 $X_1, ..., X_n$。
2. **密钥生成**：直接定义全局变量 $K_1, K_2, K_r$。
3. **掩码生成**：生成 $n$ 个随机矩阵 $S_1, ..., S_n$，维度均为 $(d_1 \times b)$。这部分假设在离线阶段完成或通过 PRG 生成，不计入在线 Setup 时间。

**需计时与统计部分**：

### 3.1 客户端本地编码 (Client Local Encoding)

对**每个客户端** $Client_i$ 执行以下流程，并统计平均耗时：

1. **分区分配 (Partitioning)**：
   - 遍历 $X_i$ 中的所有元素 $x$。
   - 计算索引 $j = \text{Hash}(K_1, x) \mod b$。
   - 将 $x$ 放入对应的桶 $P_j$ 中。
2. **构建线性系统 (Matrix Construction)**：
   - 对于每个非空分区 $P_j$ (包含 $m$ 个元素)：
   - 构建 $m \times d_1$ 的矩阵 $M$。每一行调用 `RandVector` 生成：
     - 确定起始位置 $pos = \text{Hash}(K_2, x) \mod (d_1 - w)$。
     - 在 $pos$ 到 $pos+w$ 填充随机 0/1 比特。
   - 构建目标向量 $y$ (长度 $m$)，填充随机数 (模拟 $F(K_r, x)$)。
3. **高斯消元求解 (Gaussian Elimination)**：
   - **【关键计算】** 对上述系统 $M \cdot e_j = y$ 进行求解。
   - 若 $M$ 不满秩或无解，直接随机填充 $e_j$ (为了流程继续，不卡死)。
   - *注：这是 Setup 阶段最大的计算开销，必须真实执行高斯消元相关的严谨矩阵运算。*
4. **生成编码矩阵**：
   - 将所有 $e_j$ 拼成 $d_1 \times b$ 的大矩阵 $E_i$。
5. **掩码添加 (Masking)**：
   - **【关键计算】** 执行矩阵加法：$\tilde{E}_i = E_i + S_i \mod q$。
6. **统计输出**：
   - **Time**: `Client_Encode_Time`
   - **Comm**: `Size_of(E_i)` (即 $d_1 \times b \times 8$ bytes)

### 3.2 服务器端聚合 (Server Aggregation)

1. **聚合计算**：
   - **【关键计算】** 接收 $n$ 个矩阵 $\tilde{E}_i$，执行 $n-1$ 次矩阵加法：$E_{total} = \sum \tilde{E}_i$。
2. **统计输出**：
   - **Time**: `Server_Setup_Time`

------

## 4. 阶段二：Update (增量更新)

模拟更新发生：随机选择部分客户端，为其生成新增集 $X_{add}$ 和删除集 $X_{del}$。

### 4.1 客户端增量计算 (Client Incremental Update)

对有更新的客户端执行：

1. **识别受影响分区**：
   - 计算 $X_{add} \cup X_{del}$ 中所有元素的哈希索引 $j$，得到受影响的分区列表 $J_{affected}$。
2. **重编码 (Re-encoding)**：
   - 仅对 $j \in J_{affected}$ 的分区，重新执行 **3.1 节中的步骤 2 和 3** (构建矩阵 + 高斯消元)，得到新向量 $e'_j$。
   - 计算差值 $\delta e_j = e'_j - e_{old, j}$。
3. **增量掩码添加**：
   - 生成新的随机掩码片段 $\delta S_i$ (仅针对受影响的列)。
   - **【关键计算】** 计算 $\delta \tilde{E}_i$：将 $\delta e_j$ 加上掩码。
   - 对于未受影响的列，直接填充掩码值（模拟全员参与）。
4. **统计输出**：
   - **Time**: `Client_Update_Time` (注意：通常远小于 Setup 时间)
   - **Comm**: `Size_of(Delta_E_i)` (如果采用稀疏传输优化，只统计非零列的大小；若无优化，则同 Setup)

### 4.2 服务器端更新 (Server Update)

1. **增量聚合**：
   - **【关键计算】** $E_{total}^{new} = E_{total}^{old} + \sum \delta \tilde{E}_i$。
2. **统计输出**：
   - **Time**: `Server_Update_Time`

------

## 5. 阶段三：Query (核心 PIR 模拟)

**场景**：客户端 $Client_1$ 发起 $N_{query}$ 个查询。

### 5.1 客户端查询生成 (Client Query Gen - GSW Encryption)

对于每一个查询元素 $x$：

1. **索引计算**：
   - 计算 $x$ 所在的分区索引 $j$。
   - 将 $j$ 映射为 $z$ 维超立方体坐标 $(idx_1, idx_2, ..., idx_z)$，其中第一维是元素通过RandVector算法生成的。
2. **GSW 密文生成 (PIR Query Generation)**：
   - 这是 PIR 客户端最耗时的部分。
   - **【关键计算】** 初始化 $z$ 个 GSW 密文矩阵。每个 GSW 密文是一个 $(2 \cdot N_{lwe}) \times (2 \cdot N_{lwe})$ 的大矩阵。
   - 执行矩阵填充操作（填充随机数模拟加密）。
   - *注意：如果 $N_{query}$ 很大，这里会是循环生成。*
3. **统计输出**：
   - **Time**: `Client_Query_Gen_Time`
   - **Comm**: `Query_Size` = $N_{query} \times z \times (2N_{lwe})^2 \times 8$ bytes (如果使用 GSW 形式)。

### 5.2 服务器端响应 (Server Response - Homomorphic Eval)

服务器收到查询后，对 $E_{total}$ 执行同态运算。这是性能瓶颈所在，必须精确模拟 OnionPIR/SparsePIR 的两个步骤：

1. **同态扩展 (Coefficient Expansion)**：
   - **原理**：将客户端发来的压缩查询（$z$ 个 GSW 矩阵）扩展为长度为 $b$ 的选择向量（LWE 密文形式）。
   - **【关键计算模拟】**：
     - 模拟 GSW 外部积 (External Product)。
     - 执行 **$b$ 次** 矩阵乘法：`GSW_Matrix` ($2N \times 2N$) $\times$ `LWE_Vector` ($2N \times 1$)。
     - 或者为了简化但保持量级：执行 $b$ 次 $N_{lwe} \times N_{lwe}$ 的矩阵乘法。
2. **线性检索 (Linear Retrieval)**：
   - **原理**：计算 $Result = \text{Expanded\_Vector} \cdot E_{total}$。
   - **【关键计算模拟】**：
     - 构造一个 $b \times N_{lwe}$ 的随机矩阵 $V$ (代表扩展后的同态选择向量)。
     - 构造一个 $d_1 \times b$ 的随机矩阵 $D$ (代表 $E_{total}$)。
     - 执行矩阵乘法 $R = D \times V$。
     - 结果维度应为 $d_1 \times N_{lwe}$。
3. **统计输出**：
   - **Time**: `Server_PIR_Process_Time` (必须包含扩展和检索两部分时间)
   - **Comm**: `Response_Size` = $N_{query} \times d_1 \times N_{lwe} \times 8$ bytes (LWE 密文大小)。

### 5.3 客户端解密 (Client Decryption)

1. **LWE 解密**：
   - **【关键计算】** 收到 $d_1$ 个 LWE 密文。对于每个密文（向量 $c$），计算点积 $\langle c, s \rangle$。
   - 这一步计算量相对较小，主要是向量内积。
2. **统计输出**：
   - **Time**: `Client_Decrypt_Time`

------

## 6. 实验数据记录表样例

| **阶段**   | **组件**           | **复杂度关键因子**                                     | **记录指标** | **单位** |
| ---------- | ------------------ | ------------------------------------------------------ | ------------ | -------- |
| **Setup**  | Client Encoding    | $O(d_1 \cdot w^2)$ (高斯消元)                          | Time         | ms       |
|            | Client Upload      | $d_1 \times b$                                         | Comm (Size)  | MB       |
|            | Server Aggregation | $O(n \cdot d_1 \cdot b)$ (加法)                        | Time         | ms       |
| **Update** | Client Delta Gen   | $O(\Delta \cdot w^2)$                                  | Time         | ms       |
|            | Client Delta Up    | $\Delta$ or Mask size                                  | Comm (Size)  | KB/MB    |
| **Query**  | Client Query Gen   | $z \cdot \text{GSW\_Enc}$                              | Time         | ms       |
|            | Query Upload       | $z \cdot N_{lwe}^2$                                    | Comm (Size)  | KB       |
|            | Server Process     | $b \cdot \text{MatMul} + d_1 \cdot b \cdot \text{Add}$ | Time         | ms       |
|            | Server Response    | $d_1 \cdot N_{lwe}$                                    | Comm (Size)  | KB       |
|            | Client Decrypt     | $d_1 \cdot N_{lwe}$                                    | Time         | ms       |

## 7. 总结

请按照上述步骤编写代码。对于 **Setup** 和 **Update** 阶段，重点在于实现真实的高斯消元和矩阵加法。对于 **Query** 阶段，重点在于使用大规模矩阵乘法来模拟 GSW 扩展和 LWE 检索过程。只要这些核心算子的调用次数和矩阵维度与理论一致，统计出的时间开销就是真实且具有学术说服力的 。