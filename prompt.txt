根据本目录下的性能测试实验指导文档复现的实验代码，目前存在对于PIR的处理过度复杂化的问题，实现的是非常底层和原始化的朴素PIR实现原理，这并不符合实验指导文档中提到的，应该实现的是OnionPIR这些使用了更高级的压缩技术的PIR进行模拟，为此我写了一份MUPSI_Performance_Analysis.md文档在本目录下，需要你根据这个文档的指导，将复杂且没有必要的底层PIR技术模拟进行替换，更换成更加贴合高性能PIR技术的模拟，来达到更加合理的性能测试中的计算时间和通信开销测量。然后有一点非常重要的事情需要提醒你，你现在在我物理机的wsl文件夹中，你能够正确在wsl终端中运行命令，但是你假如要创建文件不能够简单地通过你获得的路径进行创建和写入，因为你实际上运行在我的物理机中，你会把文件写到我的物理机路径中，导致wsl中没有你创建的文件。如果需要在WSL中创建文件，建议使用终端命令方式而不是create_file工具


根据本目录下的性能测试实验指导文档复现的实验代码，目前存在对于PIR的处理过度简化的问题，没有真实模拟到位的情况，需要你根据以下的指导进行优化修改，尽可能更加真实地还原好整个协议使用到底层PIR技术在性能测试中的时间及通信开销测算，具体的细节问题也需要严谨参照性能测试实验指导文档来做，首先是生成z维的张量（超立方体）时候，你怎么就简单地将索引的维度给赋值了0向量呢，这显然不合理。映射的具体数学逻辑是有b个分区，我们要查询第j个分区。将这 b个位置映射到一个边长为 L的 z维立方体中，其中 $L \approx \sqrt[z]{b}$。映射公式：将 j视为一个以L为基数的数字，将其分解为z个坐标：$$j = idx_1 \cdot L^{z-1} + idx_2 \cdot L^{z-2} + \dots + idx_z \cdot L^0$$具体的坐标计算（以 $z=2$ 平面映射为例）：$idx_1 = j // L$ （行索引）$idx_2 = j \pmod L$ （列索引）例子：如果有 $b=100$ 个分区，设 $z=2$。则 $L = \sqrt{100} = 10$。如果你要查询第 $j=42$ 个分区，映射后的坐标就是 $(4, 2)$。所以在实验模拟中，你必须体现出这个维度的差异，因为 GSW 同态扩展 是按维度进行的。A. 客户端生成查询的开销（Communication & Query Gen）一维 PIR：客户端需要加密一个长度为 $b$ 的 0/1 向量。通信量是 $O(b)$。$z$ 维 PIR：客户端只需要加密 $z$ 个“选择向量”，每个向量长度仅为 $L$。客户端生成 $z$ 组加密数据，每组包含 $L$ 个密文。计算开销模拟：你要模拟 $z \times L$ 次加密运算，而不是 $b$ 次。B. 服务器端处理的开销这是最复杂的地方。服务器收到 $z$ 组压缩后的密文，需要通过 同态乘法 把它们“组合”起来，还原出指向那个 $idx_1, ..., idx_z$ 的唯一 。同态折叠：服务器利用第 1 维的选择密文，将 $b$ 个数据折叠成 $b/L$ 个；再利用第 2 维折叠... 直到剩下 1 个。GSW 乘法量：每一次折叠都涉及大量的同态乘法。模拟逻辑：在你的实验代码中，服务器的计算时间应包含大约 $z \times b$ 次 LWE/GSW 密文间的点积或乘法运算。在模拟服务器处理时，不要直接处理长度为 $b$ 的向量。根据 $z$ 和 $b$，计算每一维的长度 $L = \lceil b^{1/z} \rceil$。模拟“维度折叠”开销：执行 $z$ 轮循环。在每一轮中，服务器需要处理当前规模的数据量。总矩阵乘法次数：模拟执行约 $z \times b$ 次同态算子运算。并且你也根本没有进行严谨的同态加密计算，密钥初始化和加密什么的根本就没有，同态加密的乘法和简单的矩阵乘法完全不一样的吧，效率差的很多的，并且进行z轮迭代的乘法也没有实现，需要还原到位呀。然后有一点非常重要的事情需要提醒你，你现在在我物理机的wsl文件夹中，你能够正确在wsl终端中运行命令，但是你假如要创建文件不能够简单地通过你获得的路径进行创建和写入，因为你实际上运行在我的物理机中，你会把文件写到我的物理机路径中，导致wsl中没有你创建的文件。如果需要在WSL中创建文件，建议使用终端命令方式而不是create_file工具

高灿：
1.不需要过分强调垂直联邦学习的背景了，我们当前主要重点是PSI，然后会议背景结合我发的图片理解，主要是要和医疗上的数据挂钩，所以首先可以调整一下引言中对于PSI的实际应用场景举例，COVID-19和远程诊断可以，后面的可以再找找PSI在医疗上的应用，然后第二段总说也是换成说真实的医疗相关场景，第三段例子没有问题，删除掉合联邦学习相关的，只强调医疗数据的求交集场景即可。
2.第四段说两方的时候可以说到支持更新的FUPSI协议，总结其痛点是拓展到多方时候的复杂度二次增长，然后将多方，多方的方案怎么还会随参与方数量二次增长？最后落到多方可更新的feather，总结其痛点是对于可更新这个特性的要么不能够支持，需要更新时重新编码，要么是支持的程度上有遗漏，要么无法删除，要么弱删除，就算是可以支持的比如feather，但是安全性上不好，会泄露访问模式、搜索模式。就分两个大类去对比痛点即可，和两方的对比多参与方扩展性，和多方的对比可更新能力的优势即可。
3.需要强调，我们最直接的对比方案是feather，然后和其对比的优势不是高效，我们会比他弱，我们的优势是安全，对访问模式的保护，所以第五段要总结到安全，以及我们方案不涉及XPSI了，我们是借助了云委托式的服务器去聚合，然后查询方和服务器一次交互获得交集的，不涉及交叉查询，和原FUPSI还是有区别的，我们方案可更新性查询需要查询旧交集元素和新增元素，是完全区别于两方FUPSI的，我明天整理出最新技术文档，需要再仔细比对并修改主要贡献。
4.国内外相关工作主要是划分类问题，先读论文，具体再说
于露雪：
1.预备知识是否和FUPSI区别开了，不能太一致，要重新有一个从我们方案出发去介绍的感觉，否则容易被查重
2.我这边已经做完我们方案的实验了，对比实验还差一点，我明天给出最新的我们方案的技术文档再对着看详细方案写的细节，会有一些细节上的实现我实验过程中做了调整，大方向和大框架基本没有变化，我看看明天对比完了再全部要改的地方标注好发给你，露雪这边的工作给我说一下是用什么写的，同步一下，后续我有一点小细节要改的我就可以自己去改，看看可不可以共享，就先画图
总：今天指出的点，明天给我一版成果，我再看，再给建议，隔一天再给一般成果这样



1.高斯消元的计算模拟上存在缺陷，需要根据以下的分析进行优化，不然效率会有一定的误差。
高斯消元是求解线性方程组的经典算法，核心分两步（针对有限域 mod q 场景，q 通常为素数）：
前向消元：通过行变换将增广矩阵 [M∣y] 转化为上三角矩阵（主对角线下方元素全为 0），且每一行的首非零元素（主元）为 1（有限域中需用模逆实现）。
回代求解：从最后一行开始，利用上三角矩阵的特性，逐步代入求解每个变量。
有限域下的关键规则：所有运算（加减乘除）都要模 q，且 “除法” 等价于乘以除数的模逆（若 q 是素数，a 的逆元 a−1 满足 a⋅a−1≡1(modq)）。
2. 前向消元（核心错误）
这是代码最关键的问题点，有限域高斯消元的核心是主元归一化 + 列消元，但代码完全缺失主元归一化，且消元逻辑不标准。
消元逻辑（重大错误）uint64_t pivot = augmented[pivot_row][col];
for (size_t i = pivot_row + 1; i < m; i++) {
    if (augmented[i][col] == 0) continue;
    uint64_t factor = augmented[i][col];
    for (size_t j = col; j <= d1; j++) {
        uint64_t val1 = Utils::mul_mod(augmented[i][j], pivot, q);
        uint64_t val2 = Utils::mul_mod(augmented[pivot_row][j], factor, q);
        augmented[i][j] = Utils::sub_mod(val1, val2, q);
    }
}
错误 1：缺失主元归一化标准流程中，找到主元后，首先要将主元行的主元化为 1（即 augmented[pivot_row][col] = 1），方法是：主元行所有元素乘以主元的模逆 inv(pivot)(modq)。代码完全跳过这一步，导致后续消元无法保证主元列下方元素为 0。
错误 2：消元方式不标准且错误代码试图用 Row[i] * pivot - Row[pivot_row] * factor 避免除法，但这会导致：
主元行的主元被放大（而非归一化为 1），后续回代无法直接求解；
模运算下，该变换无法保证 augmented[i][col] 最终为 0（比如 pivot=2,factor=3,q=5，计算后可能仍非 0）。正确的消元逻辑（有限域）：对第 i 行，计算消元因子 k=factor⋅inv(pivot)(modq)，然后 Row[i] = Row[i] - k * Row[pivot_row] \pmod{q}，这样能直接将 augmented[i][col] 消为 0。
3. 回代求解（完全错误）
回代是高斯消元的第二步，依赖前向消元得到的上三角矩阵（主元为 1），但代码不仅前向消元错误，回代阶段还跳过了核心的模逆求解，用伪随机值替代，完全失去求解意义。cpp运行uint64_t sum = augmented[i][d1];
for (size_t j = leading_col + 1; j < d1; j++) {
    uint64_t term = Utils::mul_mod(augmented[i][j], result[j], q);
    sum = Utils::sub_mod(sum, term, q);
}
// 错误：跳过模逆，用伪随机值赋值
result[leading_col] = Utils::prf_value(sum ^ augmented[i][leading_col], i);
核心错误：有限域下，回代的核心公式是：result[leading_col]=sum⋅inv(augmented[i][leading_col])(modq)其中 sum 是右侧常数项减去已求解变量的贡献。但代码完全跳过了模逆计算，用 prf_value（伪随机值）赋值，导致求解结果完全错误，只是 “模拟” 了一个结果，而非真正求解。
次要错误：找 “首非零列” 的循环从 j=0 开始，而前向消元后上三角矩阵的首非零列应大于等于当前行号，这里会多遍历无意义的列，但核心问题还是模逆缺失。
4. 其他次要问题
注释误导：注释提到 “复杂度 O (w * d1²)”（w 为带宽），但代码中没有利用带状矩阵的特性（遍历仅带宽内的列），实际复杂度是 O(m⋅d12)
总结
这段代码的框架符合高斯消元的流程（构造增广矩阵、找主元、消元、回代），但核心逻辑存在致命错误，无法正确求解有限域上的线性方程组：
前向消元缺失主元归一化（有限域高斯消元的核心步骤），消元逻辑不标准；
回代阶段跳过模逆求解，用伪随机值替代，导致效率也有差别；
关键点回顾
有限域高斯消元的核心是模逆运算（除法等价于乘逆元）和主元归一化（主元化为 1）；
代码的框架正确，但缺失上述两个核心步骤，仅为 “模拟” 高斯消元，无实际求解能力；
修正时需先实现模逆（费马小定理），再补充主元归一化，最后用标准消元 / 回代逻辑。

2.setup阶段的计时，不应该在timer停止计算后再计算通信开销吗，不然计算通信开销的时间给你算进了协议的计算开销中，你可以每一个客户端的setup循环也都各自计算时间，然后像通信开销一样在最后加到total的时间开销上呀，反正就是每个客户端的setup阶段先停止计时，将计时加到total计时里面，然后再计算通信开销，加到total通信开销里面。以及掩码的生成不是说好就不要算进计时里面了嘛，就直接像生成全局密钥一样，一开始就生成好一套规模一致的随机掩码去加即可，因为每轮生成随机掩码的时间我是不考虑到协议的计算时间开销中的，你这样每一轮都重新计算不太好，就直接在开始计时前定义好，协议计时过程中添加即可，所以update阶段也就不用再生成新的掩码了，直接用setup阶段全局初始化好的即可，update阶段也是不需要再计算生成新掩码的时间了，计算添加掩码即可

3.update阶段的客户端计时也不合理，建议也是将计时器的开始放在每个客户端的计算循环中，最后加和到total计时中，因为你现在的计时方法会将随机选择要更新的客户端，生成增加或删除的元素这些和协议本身没有关系的流程都计算进去，这是不合理的，我只需要计时每个客户端更新阶段的增量编码生成的计算时间开销，然后也是在停止计时器后再计算客户端的通信开销，把计时的区域划分好。然后对于update阶段将所有更新元素都处理为一半新增一半删除即可，不用复杂选择了，需要更新的客户端选择也是一样，不用随机，直接按顺序选前几个作为要更新的即可，然后有一个逻辑也没有处理好，就是对于不需要更新的客户端，其实也要计算编码加掩码的过程，只是不需要计算增量编码了而已，这个计时也要计入total时间开销的，并且也是要上传的编码的，update阶段的通信开销没有打印出来，记得改一下。

4.对于PIR的处理也依旧存在过度简化，没有真实模拟到位的情况，首先是生成z维的张量（超立方体）时候，你怎么就简单地将索引的维度给赋值了0向量呢，这显然不合理。映射的具体数学逻辑是有b个分区，我们要查询第j个分区。将这 b个位置映射到一个边长为 L的 z维立方体中，其中 $L \approx \sqrt[z]{b}$。映射公式：将 j视为一个以L为基数的数字，将其分解为z个坐标：$$j = idx_1 \cdot L^{z-1} + idx_2 \cdot L^{z-2} + \dots + idx_z \cdot L^0$$具体的坐标计算（以 $z=2$ 平面映射为例）：$idx_1 = j // L$ （行索引）$idx_2 = j \pmod L$ （列索引）例子：如果有 $b=100$ 个分区，设 $z=2$。则 $L = \sqrt{100} = 10$。如果你要查询第 $j=42$ 个分区，映射后的坐标就是 $(4, 2)$。所以在实验模拟中，你必须体现出这个维度的差异，因为 GSW 同态扩展 是按维度进行的。A. 客户端生成查询的开销（Communication & Query Gen）一维 PIR：客户端需要加密一个长度为 $b$ 的 0/1 向量。通信量是 $O(b)$。$z$ 维 PIR：客户端只需要加密 $z$ 个“选择向量”，每个向量长度仅为 $L$。客户端生成 $z$ 组加密数据，每组包含 $L$ 个密文。计算开销模拟：你要模拟 $z \times L$ 次加密运算，而不是 $b$ 次。B. 服务器端处理的开销这是最复杂的地方。服务器收到 $z$ 组压缩后的密文，需要通过 同态乘法 把它们“组合”起来，还原出指向那个 $idx_1, ..., idx_z$ 的唯一 。同态折叠：服务器利用第 1 维的选择密文，将 $b$ 个数据折叠成 $b/L$ 个；再利用第 2 维折叠... 直到剩下 1 个。GSW 乘法量：每一次折叠都涉及大量的同态乘法。模拟逻辑：在你的实验代码中，服务器的计算时间应包含大约 $z \times b$ 次 LWE/GSW 密文间的点积或乘法运算。并且你也根本没有进行严谨的同态加密计算，密钥初始化和加密什么的根本就没有，同态加密的乘法和简单的矩阵乘法完全不一样的吧，效率差的很多的，并且进行z轮迭代的乘法也没有实现，需要还原到位呀